"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const pdfjs = require("pdfjs-dist");
/**
 * Read a pdf file and convert it into lines of text.
 *
 * If a URL is used to fetch the PDF data a standard XMLHttpRequest(XHR) is used, which means it must follow the
 * same origin rules that any XHR does e.g. No cross domain requests without CORS.
 *
 * Parameter documentation copied from getDocument's documentation in
 * https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/pdfjs-dist/index.d.ts
 * @param source                   url or path as a string or other data types as seen in type below
 * @param pdfDataRangeTransport    Used if you want to manually server range requests for data in the PDF.  @ee viewer.js
 *                                     for an example of pdfDataRangeTransport's interface.
 * @param passwordCallback         Used to request a password if wrong or no password was provided.  The callback receives two
 *                                     parameters: function that needs to be called with new password and the reason.
 * @param progressCallback         Progress callback.
 * @return                         A promise that is resolved with an array of each page's text content.
 **/
function readPdfText(source, pdfDataRangeTransport, passwordCallback, progressCallback) {
    return __awaiter(this, void 0, void 0, function* () {
        // as any here because "getDocument"'s type signature uses different overloads rather than a single union type
        const doc = yield pdfjs.getDocument(source, pdfDataRangeTransport, passwordCallback, progressCallback)
            .promise;
        const pageCount = doc.numPages;
        const pages = [];
        for (let i = 0; i < pageCount; i++) {
            pages.push(yield parsePage(yield doc.getPage(i + 1)));
        }
        return pages;
    });
}
exports.readPdfText = readPdfText;
function parsePage(pdfPage) {
    return __awaiter(this, void 0, void 0, function* () {
        const rawContent = yield pdfPage.getTextContent();
        return parsePageItems(rawContent.items);
    });
}
/**
 * Parses individual text items generated by pdf.js This allows lower level control of what actually gets parsed.
 * For example, a consumer of this function may remove entire sections of the pdf text prior to passing items in here.
 * See parsePage function above for example usage.
 *
 * @param pdfItems     An array of pdfjs.TextContentItem items.
 **/
function parsePageItems(pdfItems) {
    const lineData = {};
    for (let i = 0; i < pdfItems.length; i++) {
        const item = pdfItems[i];
        const y = item.transform[5];
        if (!lineData.hasOwnProperty(y)) {
            lineData[y] = [];
        }
        lineData[y].push(item);
    }
    const yCoords = Object.keys(lineData)
        .map(key => Number(key))
        // b - a here because the bottom is y = 0 so we want that to be last
        .sort((a, b) => b - a)
        // insert an empty line between any 2 lines where their distance is greater than the upper line's height
        .reduce((accum, currentY, index, array) => {
        const nextY = array[index + 1];
        if (nextY != undefined) {
            const currentLineHeight = lineData[currentY].reduce((finalValue, current) => (finalValue > current.height ? finalValue : current.height), -1);
            // currentY - nextY because currentY will be higher than nextY
            if (Math.floor((currentY - nextY) / currentLineHeight) > 1) {
                const newY = currentY - currentLineHeight;
                lineData[newY] = [];
                return accum.concat(currentY, newY);
            }
        }
        return accum.concat(currentY);
    }, []);
    const lines = [];
    for (let i = 0; i < yCoords.length; i++) {
        const y = yCoords[i];
        // sort by x position (position in line)
        const lineItems = lineData[y].sort((a, b) => a.transform[4] - b.transform[4]);
        let line = lineItems.length ? lineItems[0].str : '';
        for (let j = 1; j < lineItems.length; j++) {
            const item = lineItems[j];
            const lastItem = lineItems[j - 1];
            const xDiff = item.transform[4] - (lastItem.transform[4] + lastItem.width);
            // insert spaces for items that are far apart horizontally
            if (xDiff > item.height || xDiff > lastItem.height) {
                const spaceCountA = Math.ceil(xDiff / item.height);
                let spaceCount = spaceCountA;
                if (lastItem.height !== item.height) {
                    const spaceCountB = Math.ceil(xDiff / lastItem.height);
                    spaceCount = spaceCountA > spaceCountB ? spaceCountA : spaceCountB;
                }
                line += Array(spaceCount)
                    .fill('')
                    .join(' ');
            }
            line += item.str;
        }
        lines.push(line);
    }
    return {
        lines,
    };
}
exports.parsePageItems = parsePageItems;
